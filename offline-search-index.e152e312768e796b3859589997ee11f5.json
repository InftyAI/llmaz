[{"body":"Envoy AI Gateway is an open source project for using Envoy Gateway to handle request traffic from application clients to Generative AI services.\nHow to use 1. Enable Envoy Gateway and Envoy AI Gateway Both of them are enabled by default in values.global.yaml and will be deployed in llmaz-system.\nenvoy-gateway: enabled: true envoy-ai-gateway: enabled: true However, Envoy Gateway and Envoy AI Gateway can be deployed standalone in case you want to deploy them in other namespaces.\n2. Basic AI Gateway Example To expose your models via Envoy Gateway, you need to create a GatewayClass, Gateway, and AIGatewayRoute. The following example shows how to do this.\nWe’ll deploy two models Qwen/Qwen2-0.5B-Instruct-GGUF and Qwen/Qwen2.5-Coder-0.5B-Instruct-GGUF with llama.cpp (cpu only) and expose them via Envoy AI Gateway.\nThe full example is here, apply it.\n3. Check Envoy AI Gateway APIs If Open-WebUI is enabled, you can chat via the webui (recommended), see documentation. Otherwise, following the steps below to test the Envoy AI Gateway APIs.\nI. Port-forwarding the LoadBalancer service in llmaz-system, like:\nkubectl port-forward svc/envoy-default-default-envoy-ai-gateway-dbec795a 8080:80 II. Query http://localhost:8008/v1/models | jq ., available models will be listed. Expected response will look like this:\n{ \"data\": [ { \"id\": \"qwen2-0.5b\", \"created\": 1745327294, \"object\": \"model\", \"owned_by\": \"Envoy AI Gateway\" }, { \"id\": \"qwen2.5-coder\", \"created\": 1745327294, \"object\": \"model\", \"owned_by\": \"Envoy AI Gateway\" } ], \"object\": \"list\" } III. Query http://localhost:8080/v1/chat/completions to chat with the model. Here, we ask the qwen2-0.5b model, the query will look like:\ncurl -H \"Content-Type: application/json\" -d '{ \"model\": \"qwen2-0.5b\", \"messages\": [ { \"role\": \"system\", \"content\": \"Hi.\" } ] }' http://localhost:8080/v1/chat/completions | jq . Expected response will look like this:\n{ \"choices\": [ { \"finish_reason\": \"stop\", \"index\": 0, \"message\": { \"role\": \"assistant\", \"content\": \"Hello! How can I assist you today?\" } } ], \"created\": 1745327371, \"model\": \"qwen2-0.5b\", \"system_fingerprint\": \"b5124-bc091a4d\", \"object\": \"chat.completion\", \"usage\": { \"completion_tokens\": 10, \"prompt_tokens\": 10, \"total_tokens\": 20 }, \"id\": \"chatcmpl-AODlT8xnf4OjJwpQH31XD4yehHLnurr0\", \"timings\": { \"prompt_n\": 1, \"prompt_ms\": 319.876, \"prompt_per_token_ms\": 319.876, \"prompt_per_second\": 3.1262114069201816, \"predicted_n\": 10, \"predicted_ms\": 1309.393, \"predicted_per_token_ms\": 130.9393, \"predicted_per_second\": 7.63712651587415 } } ","categories":"","description":"","excerpt":"Envoy AI Gateway is an open source project for using Envoy Gateway to …","ref":"/docs/integrations/envoy-ai-gateway/","tags":"","title":"Envoy AI Gateway"},{"body":"Prerequisites Requirements:\nKubernetes version \u003e= 1.26. LWS requires Kubernetes version v1.26 or higher. If you are using a lower Kubernetes version and most of your workloads rely on single-node inference, we may consider replacing LWS with a Deployment-based approach. This fallback plan would involve using Kubernetes Deployments to manage single-node inference workloads efficiently. See #32 for more details and updates. Helm 3, see installation. Prometheus, see installation. Note: llmaz helm chart will by default install\nEnvoy Gateway and Envoy AI Gateway as the frontier in the llmaz-system, if you already installed these two components or want to deploy in other namespaces , append --set envoy-gateway.enabled=false --set envoy-ai-gateway.enabled=false to the command below. Open WebUI as the default chatbot, if you want to disable it, append --set open-webui.enabled=false to the command below. Install a released version Install helm install llmaz oci://registry-1.docker.io/inftyai/llmaz --namespace llmaz-system --create-namespace --version 0.0.9 Uninstall helm uninstall llmaz --namespace llmaz-system kubectl delete ns llmaz-system If you want to delete the CRDs as well, run\nkubectl delete crd \\ openmodels.llmaz.io \\ backendruntimes.inference.llmaz.io \\ playgrounds.inference.llmaz.io \\ services.inference.llmaz.io Install from source Change configurations If you want to change the default configurations, please change the values in values.global.yaml.\nDo not change the values in values.yaml because it’s auto-generated and will be overwritten.\nInstall git clone https://github.com/inftyai/llmaz.git \u0026\u0026 cd llmaz kubectl create ns llmaz-system \u0026\u0026 kubens llmaz-system make helm-install Uninstall helm uninstall llmaz --namespace llmaz-system kubectl delete ns llmaz-system If you want to delete the CRDs as well, run\nkubectl delete crd \\ openmodels.llmaz.io \\ backendruntimes.inference.llmaz.io \\ playgrounds.inference.llmaz.io \\ services.inference.llmaz.io Upgrade Once you changed your code, run the command to upgrade the controller:\nIMG=\u003cimage-registry\u003e:\u003ctag\u003e make helm-upgrade ","categories":"","description":"This section introduces the installation guidance for llmaz.\n","excerpt":"This section introduces the installation guidance for llmaz.\n","ref":"/docs/installation/","tags":"","title":"Installation"},{"body":"","categories":"","description":"This section contains the llmaz integration information.\n","excerpt":"This section contains the llmaz integration information.\n","ref":"/docs/integrations/","tags":"","title":"Integrations"},{"body":"Open WebUI is a user-friendly AI interface with OpenAI-compatible APIs, serving as the default chatbot for llmaz.\nPrerequisites Make sure you’re located in llmaz-system namespace, haven’t tested with other namespaces. Make sure EnvoyGateway and Envoy AI Gateway are installed, both of them are installed by default in llmaz. See AI Gateway for more details. How to use If open-webui already installed, what you need to do is just update the OpenAI API endpoint in the admin settings. You can get the value from step2 \u0026 3 below. Otherwise, following the steps here to install open-webui.\nEnable Open WebUI in the values.global.yaml file, open-webui is enabled by default.\nopen-webui: enabled: true Optional to set the persistence=true to persist the data, recommended for production.\nRun kubectl get svc -n llmaz-system to list out the services, the output looks like:\nenvoy-default-default-envoy-ai-gateway-dbec795a LoadBalancer 10.96.145.150 \u003cpending\u003e 80:30548/TCP 132m envoy-gateway ClusterIP 10.96.52.76 \u003cnone\u003e 18000/TCP,18001/TCP,18002/TCP,19001/TCP 172m Set openaiBaseApiUrl in the values.global.yaml like:\nopen-webui: enabled: true openaiBaseApiUrl: http://envoy-default-default-envoy-ai-gateway-dbec795a.llmaz-system.svc.cluster.local/v1 Run make install-chatbot to install the chatbot.\nPort forwarding by:\nkubectl port-forward svc/open-webui 8080:80 Visit http://localhost:8080 to access the Open WebUI.\nConfigure the administrator for the first time.\nThat’s it! You can now chat with llmaz models with Open WebUI.\n","categories":"","description":"","excerpt":"Open WebUI is a user-friendly AI interface with OpenAI-compatible …","ref":"/docs/integrations/open-webui/","tags":"","title":"Open WebUI"},{"body":"Project Structure llmaz # root ├── bin # where the binaries locates, like the kustomize, ginkgo, etc. ├── chart # where the helm chart locates ├── cmd # where the main entry locates ├── docs # where all the documents locate, like examples, installation guidance, etc. ├── llmaz # where the model loader logic locates ├── pkg # where the main logic for Kubernetes controllers locates API design Core APIs See the API Reference for more details.\nInference APIs See the API Reference for more details.\n","categories":"","description":"This section contains a develop guidance for people who want to learn more about this project.\n","excerpt":"This section contains a develop guidance for people who want to learn …","ref":"/docs/develop/","tags":"","title":"Develop Guidance"},{"body":"Currently, llmaz has already integrated metrics. This document provides deployment steps explaining how to install and configure Prometheus Operator in a Kubernetes cluster.\nInstall the prometheus operator Please follow the documentation to install\n# Installing the prometheus operator root@VM-0-5-ubuntu:/home/ubuntu# kubectl get pods NAME READY STATUS RESTARTS AGE prometheus-operator-55b5c96cf8-jl2nx 1/1 Running 0 12s Ensure that the Prometheus Operator Pod is running successfully.\nInstall the ServiceMonitor CR for llmaz To enable monitoring for the llmaz system, you need to install the ServiceMonitor custom resource (CR). You can either modify the Helm chart prometheus according to the documentation or use make install-prometheus in Makefile.\nUsing Helm Chart: to modify the values.global.yaml prometheus: # -- Whether to enable Prometheus metrics exporting. enable: true Using Makefile Command: make install-prometheus root@VM-0-5-ubuntu:/home/ubuntu/llmaz# make install-prometheus kubectl apply --server-side -k config/prometheus serviceaccount/llmaz-prometheus serverside-applied clusterrole.rbac.authorization.k8s.io/llmaz-prometheus serverside-applied clusterrolebinding.rbac.authorization.k8s.io/llmaz-prometheus serverside-applied prometheus.monitoring.coreos.com/llmaz-prometheus serverside-applied servicemonitor.monitoring.coreos.com/llmaz-controller-manager-metrics-monitor serverside-applied Check Related Resources Verify that the necessary resources have been created:\nServiceMonitor root@VM-0-5-ubuntu:/home/ubuntu/llmaz# kubectl get ServiceMonitor -n llmaz-system NAME AGE llmaz-controller-manager-metrics-monitor 59s Prometheus Pods root@VM-0-5-ubuntu:/home/ubuntu/llmaz# kubectl get pods -n llmaz-system NAME READY STATUS RESTARTS AGE llmaz-controller-manager-7ff8f7d9bd-vztls 2/2 Running 0 28s prometheus-llmaz-prometheus-0 2/2 Running 0 27s Services root@VM-0-5-ubuntu:/home/ubuntu/llmaz# kubectl get svc -n llmaz-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE llmaz-controller-manager-metrics-service ClusterIP 10.96.79.226 \u003cnone\u003e 8443/TCP 46s llmaz-webhook-service ClusterIP 10.96.249.226 \u003cnone\u003e 443/TCP 46s prometheus-operated ClusterIP None \u003cnone\u003e 9090/TCP 45s View metrics using the prometheus UI Use port forwarding to access the Prometheus UI from your local machine:\nroot@VM-0-5-ubuntu:/home/ubuntu# kubectl port-forward services/prometheus-operated 9090:9090 --address 0.0.0.0 -n llmaz-system Forwarding from 0.0.0.0:9090 -\u003e 9090 If using kind, we can use port-forward, kubectl port-forward services/prometheus-operated 39090:9090 --address 0.0.0.0 -n llmaz-system This allows us to access prometheus using a browser: http://localhost:9090/query\n","categories":"","description":"","excerpt":"Currently, llmaz has already integrated metrics. This document …","ref":"/docs/integrations/prometheus-operator/","tags":"","title":"Prometheus Operator"},{"body":"","categories":"","description":"This section contains the llmaz reference information.\n","excerpt":"This section contains the llmaz reference information.\n","ref":"/docs/reference/","tags":"","title":"Reference"},{"body":"If you want to integrate more backends into llmaz, please refer to this PR. It’s always welcomed.\nllama.cpp llama.cpp is to enable LLM inference with minimal setup and state-of-the-art performance on a wide variety of hardware - locally and in the cloud.\nSGLang SGLang is yet another fast serving framework for large language models and vision language models.\nText-Generation-Inference text-generation-inference is a Rust, Python and gRPC server for text generation inference. Used in production at Hugging Face to power Hugging Chat, the Inference API and Inference Endpoint.\nollama ollama is running with Llama 3.2, Mistral, Gemma 2, and other large language models, based on llama.cpp, aims for local deploy.\nvLLM vLLM is a high-throughput and memory-efficient inference and serving engine for LLMs\n","categories":"","description":"","excerpt":"If you want to integrate more backends into llmaz, please refer to …","ref":"/docs/integrations/support-backends/","tags":"","title":"Supported Inference Backends"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/","tags":"","title":"Documentation"},{"body":" Learn More GitHub Easy, advanced inference platform for large language models on Kubernetes.\nKey Features\nEasy of Use People can quick deploy a LLM service with minimal configurations.\nBroad Backends Support llmaz supports a wide range of advanced inference backends for different scenarios, like vLLM, Text-Generation-Inference, SGLang, llama.cpp. Find the full list of supported backends here.\nAccelerator Fungibility llmaz supports serving the same LLM with various accelerators to optimize cost and performance.\nVarious Model Providers llmaz supports a wide range of model providers, such as HuggingFace, ModelScope, ObjectStores. llmaz will automatically handle the model loading, requiring no effort from users.\nMulti-Host Support llmaz supports both single-host and multi-host scenarios with LWS from day 0.\nAI Gateway Support Offering capabilities like token-based rate limiting, model routing with the integration of Envoy AI Gateway.\nBuild-in ChatUI Out-of-the-box chatbot support with the integration of Open WebUI, offering capacities like function call, RAG, web search and more, see configurations here.\nScaling Efficiency llmaz supports horizontal scaling with HPA by default and will integrate with autoscaling components like Cluster-Autoscaler or Karpenter for smart scaling across different clouds.\nEfficient Model Distribution (WIP) Out-of-the-box model cache system support with Manta, still under development right now with architecture reframing.\n","categories":"","description":"","excerpt":" Learn More GitHub Easy, advanced inference platform for large …","ref":"/","tags":"","title":"llmaz"},{"body":"Resource Types OpenModel OpenModel Appears in:\nOpenModel is the Schema for the open models API\nFieldDescription apiVersionstringllmaz.io/v1alpha1 kindstringOpenModel spec [Required] ModelSpec No description provided. status [Required] ModelStatus No description provided. Flavor Appears in:\nInferenceConfig Flavor defines the accelerator requirements for a model and the necessary parameters in autoscaling. Right now, it will be used in two places:\nPod scheduling with node selectors specified. Cluster autoscaling with essential parameters provided. FieldDescription name [Required] FlavorName Name represents the flavor name, which will be used in model claim.\nlimits k8s.io/api/core/v1.ResourceList Limits defines the required accelerators to serve the model for each replica, like \u003cnvidia.com/gpu: 8\u003e. For multi-hosts cases, the limits here indicates the resource requirements for each replica, usually equals to the TP size. Not recommended to set the cpu and memory usage here:\nif using playground, you can define the cpu/mem usage at backendConfig. if using inference service, you can define the cpu/mem at the container resources. However, if you define the same accelerator resources at playground/service as well, the resources will be overwritten by the flavor limit here. nodeSelector map[string]string NodeSelector represents the node candidates for Pod placements, if a node doesn't meet the nodeSelector, it will be filtered out in the resourceFungibility scheduler plugin. If nodeSelector is empty, it means every node is a candidate.\nparams map[string]string Params stores other useful parameters and will be consumed by cluster-autoscaler / Karpenter for autoscaling or be defined as model parallelism parameters like TP or PP size. E.g. with autoscaling, when scaling up nodes with 8x Nvidia A00, the parameter can be injected with \u003cINSTANCE-TYPE: p4d.24xlarge\u003e for AWS. Preset parameters: TP, PP, INSTANCE-TYPE.\nFlavorName (Alias of string)\nAppears in:\nFlavor InferenceConfig Appears in:\nModelSpec InferenceConfig represents the inference configurations for the model.\nFieldDescription flavors []Flavor Flavors represents the accelerator requirements to serve the model. Flavors are fungible following the priority represented by the slice order.\nModelHub Appears in:\nModelSource ModelHub represents the model registry for model downloads.\nFieldDescription name string Name refers to the model registry, such as huggingface.\nmodelID [Required] string ModelID refers to the model identifier on model hub, such as meta-llama/Meta-Llama-3-8B.\nfilename [Required] string Filename refers to a specified model file rather than the whole repo. This is helpful to download a specified GGUF model rather than downloading the whole repo which includes all kinds of quantized models. TODO: this is only supported with Huggingface, add support for ModelScope in the near future. Note: once filename is set, allowPatterns and ignorePatterns should be left unset.\nrevision string Revision refers to a Git revision id which can be a branch name, a tag, or a commit hash.\nallowPatterns []string AllowPatterns refers to files matched with at least one pattern will be downloaded.\nignorePatterns []string IgnorePatterns refers to files matched with any of the patterns will not be downloaded.\nModelName (Alias of string)\nAppears in:\nModelRef\nModelSpec\nModelRef Appears in:\nModelRef refers to a created Model with it's role.\nFieldDescription name [Required] ModelName Name represents the model name.\nrole ModelRole Role represents the model role once more than one model is required. Such as a draft role, which means running with SpeculativeDecoding, and default arguments for backend will be searched in backendRuntime with the name of speculative-decoding.\nModelRole (Alias of string)\nAppears in:\nModelRef ModelSource Appears in:\nModelSpec ModelSource represents the source of the model. Only one model source will be used.\nFieldDescription modelHub ModelHub ModelHub represents the model registry for model downloads.\nuri URIProtocol URI represents a various kinds of model sources following the uri protocol, protocol://, e.g.\noss://./ ollama://llama3.3 host:// ModelSpec Appears in:\nOpenModel ModelSpec defines the desired state of Model\nFieldDescription familyName [Required] ModelName FamilyName represents the model type, like llama2, which will be auto injected to the labels with the key of llmaz.io/model-family-name.\nsource [Required] ModelSource Source represents the source of the model, there're several ways to load the model such as loading from huggingface, OCI registry, s3, host path and so on.\ninferenceConfig [Required] InferenceConfig InferenceConfig represents the inference configurations for the model.\nModelStatus Appears in:\nOpenModel ModelStatus defines the observed state of Model\nFieldDescription conditions [Required] []k8s.io/apimachinery/pkg/apis/meta/v1.Condition Conditions represents the Inference condition.\nURIProtocol (Alias of string)\nAppears in:\nModelSource URIProtocol represents the protocol of the URI.\n","categories":"","description":"Generated API reference documentation for llmaz.io/v1alpha1.","excerpt":"Generated API reference documentation for llmaz.io/v1alpha1.","ref":"/docs/reference/core.v1alpha1/","tags":"","title":"llmaz core API"},{"body":"Resource Types Playground Service Playground Appears in:\nPlayground is the Schema for the playgrounds API\nFieldDescription apiVersionstringinference.llmaz.io/v1alpha1 kindstringPlayground spec [Required] PlaygroundSpec No description provided. status [Required] PlaygroundStatus No description provided. Service Appears in:\nService is the Schema for the services API\nFieldDescription apiVersionstringinference.llmaz.io/v1alpha1 kindstringService spec [Required] ServiceSpec No description provided. status [Required] ServiceStatus No description provided. BackendName (Alias of string)\nAppears in:\nBackendRuntimeConfig BackendRuntime Appears in:\nBackendRuntime is the Schema for the backendRuntime API\nFieldDescription spec [Required] BackendRuntimeSpec No description provided. status [Required] BackendRuntimeStatus No description provided. BackendRuntimeConfig Appears in:\nPlaygroundSpec FieldDescription backendName BackendName BackendName represents the inference backend under the hood, e.g. vLLM.\nversion string Version represents the backend version if you want a different one from the default version.\nenvs []k8s.io/api/core/v1.EnvVar Envs represents the environments set to the container.\nconfigName [Required] string ConfigName represents the recommended configuration name for the backend, It will be inferred from the models in the runtime if not specified, e.g. default, speculative-decoding.\nargs []string Args defined here will \"append\" the args defined in the recommendedConfig, either explicitly configured in configName or inferred in the runtime.\nresources ResourceRequirements Resources represents the resource requirements for backend, like cpu/mem, accelerators like GPU should not be defined here, but at the model flavors, or the values here will be overwritten. Resources defined here will \"overwrite\" the resources in the recommendedConfig.\nsharedMemorySize k8s.io/apimachinery/pkg/api/resource.Quantity SharedMemorySize represents the size of /dev/shm required in the runtime of inference workload. SharedMemorySize defined here will \"overwrite\" the sharedMemorySize in the recommendedConfig.\nBackendRuntimeSpec Appears in:\nBackendRuntime BackendRuntimeSpec defines the desired state of BackendRuntime\nFieldDescription command []string Command represents the default command for the backendRuntime.\nimage [Required] string Image represents the default image registry of the backendRuntime. It will work together with version to make up a real image.\nversion [Required] string Version represents the default version of the backendRuntime. It will be appended to the image as a tag.\nenvs []k8s.io/api/core/v1.EnvVar Envs represents the environments set to the container.\nlifecycle k8s.io/api/core/v1.Lifecycle Lifecycle represents hooks executed during the lifecycle of the container.\nlivenessProbe k8s.io/api/core/v1.Probe Periodic probe of backend liveness. Backend will be restarted if the probe fails. Cannot be updated.\nreadinessProbe k8s.io/api/core/v1.Probe Periodic probe of backend readiness. Backend will be removed from service endpoints if the probe fails.\nstartupProbe k8s.io/api/core/v1.Probe StartupProbe indicates that the Backend has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the backend will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a backend's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation.\nrecommendedConfigs []RecommendedConfig RecommendedConfigs represents the recommended configurations for the backendRuntime.\nBackendRuntimeStatus Appears in:\nBackendRuntime BackendRuntimeStatus defines the observed state of BackendRuntime\nFieldDescription conditions [Required] []k8s.io/apimachinery/pkg/apis/meta/v1.Condition Conditions represents the Inference condition.\nElasticConfig Appears in:\nPlaygroundSpec FieldDescription minReplicas int32 MinReplicas indicates the minimum number of inference workloads based on the traffic. Default to 1. MinReplicas couldn't be 0 now, will support serverless in the future.\nmaxReplicas int32 MaxReplicas indicates the maximum number of inference workloads based on the traffic. Default to nil means there's no limit for the instance number.\nscaleTrigger ScaleTrigger ScaleTrigger defines the rules to scale the workloads. Only one trigger cloud work at a time, mostly used in Playground. ScaleTrigger defined here will \"overwrite\" the scaleTrigger in the recommendedConfig.\nHPATrigger Appears in:\nScaleTrigger HPATrigger represents the configuration of the HorizontalPodAutoscaler. Inspired by kubernetes.io/pkg/apis/autoscaling/types.go#HorizontalPodAutoscalerSpec. Note: HPA component should be installed in prior.\nFieldDescription metrics []k8s.io/api/autoscaling/v2.MetricSpec metrics contains the specifications for which to use to calculate the desired replica count (the maximum replica count across all metrics will be used). The desired replica count is calculated multiplying the ratio between the target value and the current value by the current number of pods. Ergo, metrics used must decrease as the pod count is increased, and vice-versa. See the individual metric source types for more information about how each type of metric must respond.\nbehavior k8s.io/api/autoscaling/v2.HorizontalPodAutoscalerBehavior behavior configures the scaling behavior of the target in both Up and Down directions (scaleUp and scaleDown fields respectively). If not set, the default HPAScalingRules for scale up and scale down are used.\nPlaygroundSpec Appears in:\nPlayground PlaygroundSpec defines the desired state of Playground\nFieldDescription replicas int32 Replicas represents the replica number of inference workloads.\nmodelClaim ModelClaim ModelClaim represents claiming for one model, it's a simplified use case of modelClaims. Most of the time, modelClaim is enough. ModelClaim and modelClaims are exclusive configured.\nmodelClaims ModelClaims ModelClaims represents claiming for multiple models for more complicated use cases like speculative-decoding. ModelClaims and modelClaim are exclusive configured.\nbackendRuntimeConfig BackendRuntimeConfig BackendRuntimeConfig represents the inference backendRuntime configuration under the hood, e.g. vLLM, which is the default backendRuntime.\nelasticConfig [Required] ElasticConfig ElasticConfig defines the configuration for elastic usage, e.g. the max/min replicas.\nPlaygroundStatus Appears in:\nPlayground PlaygroundStatus defines the observed state of Playground\nFieldDescription conditions [Required] []k8s.io/apimachinery/pkg/apis/meta/v1.Condition Conditions represents the Inference condition.\nreplicas [Required] int32 Replicas track the replicas that have been created, whether ready or not.\nselector [Required] string Selector points to the string form of a label selector which will be used by HPA.\nRecommendedConfig Appears in:\nBackendRuntimeSpec RecommendedConfig represents the recommended configurations for the backendRuntime, user can choose one of them to apply.\nFieldDescription name [Required] string Name represents the identifier of the config.\nargs []string Args represents all the arguments for the command. Argument around with {{ .CONFIG }} is a configuration waiting for render.\nresources ResourceRequirements Resources represents the resource requirements for backend, like cpu/mem, accelerators like GPU should not be defined here, but at the model flavors, or the values here will be overwritten.\nsharedMemorySize k8s.io/apimachinery/pkg/api/resource.Quantity SharedMemorySize represents the size of /dev/shm required in the runtime of inference workload.\nscaleTrigger ScaleTrigger ScaleTrigger defines the rules to scale the workloads. Only one trigger cloud work at a time.\nResourceRequirements Appears in:\nBackendRuntimeConfig\nRecommendedConfig\nTODO: Do not support DRA yet, we can support that once needed.\nFieldDescription limits k8s.io/api/core/v1.ResourceList Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nrequests k8s.io/api/core/v1.ResourceList Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nScaleTrigger Appears in:\nElasticConfig\nRecommendedConfig\nScaleTrigger defines the rules to scale the workloads. Only one trigger cloud work at a time, mostly used in Playground.\nFieldDescription hpa [Required] HPATrigger HPA represents the trigger configuration of the HorizontalPodAutoscaler.\nServiceSpec Appears in:\nService ServiceSpec defines the desired state of Service. Service controller will maintain multi-flavor of workloads with different accelerators for cost or performance considerations.\nFieldDescription modelClaims [Required] ModelClaims ModelClaims represents multiple claims for different models.\nreplicas int32 Replicas represents the replica number of inference workloads.\nworkloadTemplate [Required] sigs.k8s.io/lws/api/leaderworkerset/v1.LeaderWorkerTemplate WorkloadTemplate defines the template for leader/worker pods\nrolloutStrategy sigs.k8s.io/lws/api/leaderworkerset/v1.RolloutStrategy RolloutStrategy defines the strategy that will be applied to update replicas when a revision is made to the leaderWorkerTemplate.\nServiceStatus Appears in:\nService ServiceStatus defines the observed state of Service\nFieldDescription conditions [Required] []k8s.io/apimachinery/pkg/apis/meta/v1.Condition Conditions represents the Inference condition.\nreplicas [Required] int32 Replicas track the replicas that have been created, whether ready or not.\nselector [Required] string Selector points to the string form of a label selector, the HPA will be able to autoscale your resource.\n","categories":"","description":"Generated API reference documentation for inference.llmaz.io/v1alpha1.","excerpt":"Generated API reference documentation for inference.llmaz.io/v1alpha1.","ref":"/docs/reference/inference.v1alpha1/","tags":"","title":"llmaz inference API"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"}]